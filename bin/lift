#!/usr/bin/env lua

local cli = require 'lift.cli'
local task = require 'lift.task'
local async = require 'lift.async'
local config = require 'lift.config'
local loader = require 'lift.loader'
local diagnostics = require 'lift.diagnostics'

-- enable colors by default on supported terminals
require('lift.color').set_enabled(os.getenv('TERM') or os.getenv('ANSICON'))

os.exit(diagnostics.wrap(function()

  -- parse key=value configs at the beginning of arg list
  local cli_scope = config:new_parent('cli')
  cli.parse_config(arg)
  diagnostics.set_tracing(config:get_bool('tracing'))

  -- add 'lift executable'-specific files to the ${load_path}
  config:insert_unique('load_path', config.LIFT_SRC_DIR..'/files/lift')

  -- run init scripts
  local top_scope = loader.init()

  -- make cli configs override init configs
  assert(top_scope:get_parent() == cli_scope)
  top_scope:set_parent(cli_scope:get_parent())
  cli_scope:set_parent(config:get_parent())
  config:set_parent(cli_scope)

  -- run CLI scripts
  local app = cli.new()
  loader.load_all('cli', nil, app)

  -- default command is an alias to the 'task run' command
  app:delegate_to(app:get_command('task run'))

  -- command 'list' is an alias to 'task list'
  app:command 'list' :delegate_to(app:get_command 'task list')
    :desc('list [pattern]', 'Show list of tasks (that match a pattern)')

  -- run the CLI in a new thread
  local future = async(function()
    return app:process(arg)
  end)

  async.run() -- main loop
  future:check_error() -- propagate CLI errors
  async.check_errors() -- propagate unchecked errors from other threads

end))
